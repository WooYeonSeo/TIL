### Scope
자바스크립트에서 실행컨텍스트란 코드 실행에 필요한 환경을 말합니다.
물리적으로는 객체형태를 가지며 그 안에는 변수객체, 스코프체인, this 프로퍼티를 소유합니다.
위의 코드에서는 두개의 함수 컨텍스트가 생성이된다.

1. 전역컨텍스트
2. 전역컨텍스트-say함수 컨텍스트
3. 전역컨텍스트-say함수 컨텍스트-wow함수 컨텍스트

```javascript
var name = "zero"; // (1)변수 선언 (6)변수 대입

function wow(word) {
  // (2)변수 선언 (3)변수 대입
  console.log(word + " " + name); // (11)
}

function say() {
  // (4)변수 선언 (5)변수 대입
  var name = "nero"; // (8)
  console.log(name); // (9)
  wow("hello"); // (10)
}

say(); // (7)
```

> 어제의 궁금증 : 전역컨텍스트는 무엇이 다르고 제일 먼저 생성되는 게 맞을까?
> 다른점1 : 일단 전역 컨텍스트는 가장 먼저 생기는 것이 맞다. 하지만 일반적인 실행 컨텍스트와는 다르게 argument 객체가 없고 전역객체 하나만을 포함하는 스코프 체인을 갖는다.
> 저 말을 이해하려면 컨텍스트가 생성될 때의 순서를 알아야하는데. 컨텍스트가 생성될 때 
> 1) 활성객체 생성, arguments 객체 생성 (VO) 2) 스코프 정보 생성 3) 지역변수생성 4) this 바인딩 의 순서로 생성노딘다
> 그런데 전역객체에서는 1) 에서 argument 생성이 없다는 차이점이 있다.


다시 코드로 돌아가서 say함수의 컨텍스트가 생성되는 과정을 보면.
say함수의 활성객체가 생성되고, argument가 없으므로 따로 활성객체에 객체가 생성되지는 않는다.
그리고 스코프 정보가 생성된다. 
(이때 현재 실행되고 있는 컨텍스트의 scope 를 그대로 복사한 후 현재 생성된 변수객체를 체인의 제일 앞에 추가한다) 
-> say함수의 [[scope]]프로퍼티는 0:전역객체 - 1:say변수객체 의 프로토타입 체인을 갖게 되는 것
-> wow함수는  0:전역객체 - 1:say변수객체 - 2: wow변수객체
> 어제의 궁금증 2 : scope는 선언 때 만들어지는데 왜 실행컨텍스트가 만들어 질 때 scope 정보가 생성될까?
> 답 : 함수의 [[scope]] 프로퍼티는 선언될 때 생성되고
>      스코프 체인은 실행될 때 컨텍스트가 만들어지면서 만들어진다. 


그리고 이러한 방식으로 스코프 체인이 형성되어 있기 때문에 say의 실행 컨텍스트는 사라졌지만 say의 변수객체는 스코프 체인에 남아있기 때문에 참조가 가능하고
이런 것을 클로저라고 한다.


### This
그럼 위 함수에서 this는 어떻게 될까?
his는 메소드를 호출한 객체가 저장되어 있는 속성으로 각 함수가 바인딩 된다.
